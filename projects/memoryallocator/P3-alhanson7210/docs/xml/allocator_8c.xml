<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.16">
  <compounddef id="allocator_8c" kind="file" language="C++">
    <compoundname>allocator.c</compoundname>
    <includes local="no">stdio.h</includes>
    <includes local="no">stdlib.h</includes>
    <includes local="no">stdint.h</includes>
    <includes local="no">stddef.h</includes>
    <includes local="no">sys/mman.h</includes>
    <includes local="no">string.h</includes>
    <includes local="no">unistd.h</includes>
    <includes local="no">stdbool.h</includes>
    <includes local="no">assert.h</includes>
    <includes local="no">pthread.h</includes>
    <includes local="no">errno.h</includes>
    <includes local="no">malloc.h</includes>
    <includes refid="allocator_8h" local="yes">allocator.h</includes>
    <includes refid="debug_8h" local="yes">debug.h</includes>
    <incdepgraph>
      <node id="9">
        <label>stdbool.h</label>
      </node>
      <node id="10">
        <label>assert.h</label>
      </node>
      <node id="4">
        <label>stdint.h</label>
      </node>
      <node id="6">
        <label>sys/mman.h</label>
      </node>
      <node id="3">
        <label>stdlib.h</label>
      </node>
      <node id="12">
        <label>errno.h</label>
      </node>
      <node id="13">
        <label>malloc.h</label>
      </node>
      <node id="15">
        <label>debug.h</label>
        <link refid="debug_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
      </node>
      <node id="5">
        <label>stddef.h</label>
      </node>
      <node id="11">
        <label>pthread.h</label>
      </node>
      <node id="7">
        <label>string.h</label>
      </node>
      <node id="8">
        <label>unistd.h</label>
      </node>
      <node id="1">
        <label>allocator.c</label>
        <link refid="allocator_8c"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="13" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
        <childnode refid="15" relation="include">
        </childnode>
      </node>
      <node id="14">
        <label>allocator.h</label>
        <link refid="allocator_8h"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="10" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>stdio.h</label>
      </node>
    </incdepgraph>
      <sectiondef kind="var">
      <memberdef kind="variable" id="allocator_8c_1a4c9da321d9716d43277851380b746c06" prot="public" static="no" mutable="no">
        <type>pthread_mutex_t</type>
        <definition>pthread_mutex_t thread_safety</definition>
        <argsstring></argsstring>
        <name>thread_safety</name>
        <initializer>= PTHREAD_MUTEX_INITIALIZER</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="allocator.c" line="52" column="17" bodyfile="allocator.c" bodystart="52" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="allocator_8c_1a16e4f54f08fa2ef1574b413d64a94d44" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void print_memory</definition>
        <argsstring>(void)</argsstring>
        <name>print_memory</name>
        <param>
          <type>void</type>
        </param>
        <briefdescription>
<para>Prints out the current memory state, including both the regions and blocks. Entries are printed in order, so there is an implied link from the topmost entry to the next, and so on. </para>
        </briefdescription>
        <detaileddescription>
<para>print_memory prints the current memory state from our linked list of memory <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>void</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="allocator.c" line="61" column="6" bodyfile="allocator.c" bodystart="61" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="allocator_8c_1a22a50f56d0ca25cf15ae958e096a9776" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void write_memory</definition>
        <argsstring>(FILE *fp)</argsstring>
        <name>write_memory</name>
        <param>
          <type>FILE *</type>
          <declname>fp</declname>
        </param>
        <briefdescription>
<para>Prints out the current memory state, including both the regions and blocks. Entries are printed in order, so there is an implied link from the topmost entry to the next, and so on. </para>
        </briefdescription>
        <detaileddescription>
<para>write_memory prints the current memory state from our linked list of memory without calling malloc <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fp</parametername>
</parameternamelist>
<parameterdescription>
<para>file pointer </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="allocator.c" line="94" column="6" bodyfile="allocator.c" bodystart="94" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="allocator_8c_1a512132f6d325316860cc6ac6bf0a366c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void* reuse</definition>
        <argsstring>(size_t size)</argsstring>
        <name>reuse</name>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>reuse returns the first memory region that the requested allocation size fits into -which includes the size fo the <ref refid="structmem__block" kindref="compound">mem_block</ref> struct that will be split </para>
        </briefdescription>
        <detaileddescription>
<para>Resusing blocks of memory within our linked list of memory <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>requested allocation size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="allocator.c" line="128" column="6" bodyfile="allocator.c" bodystart="128" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="allocator_8c_1a7ac38fce3243a7dcf448301ee9ffd392" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void* malloc</definition>
        <argsstring>(size_t size)</argsstring>
        <name>malloc</name>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>allocating memory from a given ammount of bytes given from size; returning the needed space via malloc_name; it handles resizing over-allocated space, memory allocation of new memory, or returns NULL if certain sizes are. </para>
        </briefdescription>
        <detaileddescription>
<para>malloc calls malloc_name to allocate memory via mmap NOTE: an integer overflow would not be detected in malloc(nmemb * size); <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>requested allocation size </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="allocator.c" line="246" column="6" bodyfile="allocator.c" bodystart="246" bodyend="254"/>
      </memberdef>
      <memberdef kind="function" id="allocator_8c_1aec0d19cf0c75e35fef6e0c1248dc781e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void* malloc_name</definition>
        <argsstring>(size_t size, char *name)</argsstring>
        <name>malloc_name</name>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <param>
          <type>char *</type>
          <declname>name</declname>
        </param>
        <briefdescription>
<para>To perform the allocation, place a metadata struct at the start of a free memory address and then return a pointer to the ‘data’ portion of the memory shown in the first figure. </para>
        </briefdescription>
        <detaileddescription>
<para>Request new memory regions from the kernel via mmap <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>requested allocation size </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>name</parametername>
</parameternamelist>
<parameterdescription>
<para>name of the allocated block </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="allocator.c" line="264" column="6" bodyfile="allocator.c" bodystart="264" bodyend="430"/>
      </memberdef>
      <memberdef kind="function" id="allocator_8c_1afbedc913aa4651b3c3b4b3aecd9b4711" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void free</definition>
        <argsstring>(void *ptr)</argsstring>
        <name>free</name>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>set usage to zero or unmap memory region </para>
        </briefdescription>
        <detaileddescription>
<para>The <ref refid="allocator_8c_1afbedc913aa4651b3c3b4b3aecd9b4711" kindref="member">free()</ref> function frees the memory space pointed to by ptr, which must have been returned by a previous call to <ref refid="allocator_8c_1a7ac38fce3243a7dcf448301ee9ffd392" kindref="member">malloc()</ref>, <ref refid="allocator_8c_1a62b7798461bd461da64c5f9d35feddf7" kindref="member">calloc()</ref>, or <ref refid="allocator_8c_1a1a6b5e8d2f1c37e5b43e4345586075be" kindref="member">realloc()</ref>. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>memory block pointed to by ptr </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="allocator.c" line="439" column="6" bodyfile="allocator.c" bodystart="439" bodyend="584"/>
      </memberdef>
      <memberdef kind="function" id="allocator_8c_1a62b7798461bd461da64c5f9d35feddf7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void* calloc</definition>
        <argsstring>(size_t nmemb, size_t size)</argsstring>
        <name>calloc</name>
        <param>
          <type>size_t</type>
          <declname>nmemb</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>The <ref refid="allocator_8c_1a62b7798461bd461da64c5f9d35feddf7" kindref="member">calloc()</ref> function allocates memory for an array of nmemb elements of size bytes each and returns a pointer to the allocated memory. </para>
        </briefdescription>
        <detaileddescription>
<para>calloc will clear the memory and return NULL if overflow occurs, <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>requested allocation size </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nmemb</parametername>
</parameternamelist>
<parameterdescription>
<para>elements of size bytes each and returns a pointer to the allocated memory </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="allocator.c" line="593" column="6" bodyfile="allocator.c" bodystart="593" bodyend="629"/>
      </memberdef>
      <memberdef kind="function" id="allocator_8c_1a1a6b5e8d2f1c37e5b43e4345586075be" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void *</type>
        <definition>void* realloc</definition>
        <argsstring>(void *ptr, size_t size)</argsstring>
        <name>realloc</name>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>size</declname>
        </param>
        <briefdescription>
<para>memory block of memory sectioned out into chunks, new space within a region, or NULL if there were any issues raised </para>
        </briefdescription>
        <detaileddescription>
<para>The <ref refid="allocator_8c_1a1a6b5e8d2f1c37e5b43e4345586075be" kindref="member">realloc()</ref> function changes the size of the memory block pointed to by ptr to size bytes. The contents will be unchanged in the range from the start of the region up to the minimum of the old and new sizes <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>size</parametername>
</parameternamelist>
<parameterdescription>
<para>requested size </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>memory block pointed to by ptr </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="allocator.c" line="640" column="6" bodyfile="allocator.c" bodystart="640" bodyend="681"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>To use (one specific command): LD_PRELOAD=/allocator.so command (&apos;command&apos; will run with your allocator) </para>
    </briefdescription>
    <detaileddescription>
<para>Explores memory management at the C runtime level.</para>
<para>To use (all following commands): export LD_PRELOAD=/allocator.so (Everything after this point will use your custom allocator <ndash/> be careful!) </para>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"></codeline>
<codeline lineno="15"><highlight class="comment">/*</highlight></codeline>
<codeline lineno="16"><highlight class="comment"><sp/>*<sp/>list<sp/>of<sp/>finished<sp/>methods(coding<sp/>logic)</highlight></codeline>
<codeline lineno="17"><highlight class="comment"><sp/>*<sp/>malloc</highlight></codeline>
<codeline lineno="18"><highlight class="comment"><sp/>*<sp/>print_memory</highlight></codeline>
<codeline lineno="19"><highlight class="comment"><sp/>*<sp/>calloc</highlight></codeline>
<codeline lineno="20"><highlight class="comment"><sp/>*<sp/>reuse</highlight></codeline>
<codeline lineno="21"><highlight class="comment"><sp/>*<sp/>malloc_name</highlight></codeline>
<codeline lineno="22"><highlight class="comment"><sp/>*<sp/>free</highlight></codeline>
<codeline lineno="23"><highlight class="comment"><sp/>*<sp/>realloc</highlight></codeline>
<codeline lineno="24"><highlight class="comment"><sp/>*</highlight></codeline>
<codeline lineno="25"><highlight class="comment"><sp/>*<sp/>syntactical<sp/>check</highlight></codeline>
<codeline lineno="26"><highlight class="comment"><sp/>*<sp/>TODO:<sp/>print_memory<sp/>reuse<sp/>malloc<sp/>malloc_name<sp/>free<sp/>calloc<sp/>realloc</highlight></codeline>
<codeline lineno="27"><highlight class="comment"><sp/>*<sp/></highlight></codeline>
<codeline lineno="28"><highlight class="comment"><sp/>*<sp/>TODO:<sp/>ask<sp/>about<sp/>here</highlight></codeline>
<codeline lineno="29"><highlight class="comment"><sp/>*<sp/>(3)<sp/>in<sp/>malloc_name</highlight></codeline>
<codeline lineno="30"><highlight class="comment"><sp/>*<sp/>(1)<sp/>in<sp/>free</highlight></codeline>
<codeline lineno="31"><highlight class="comment"><sp/>*<sp/>(1)<sp/>in<sp/>calloc</highlight></codeline>
<codeline lineno="32"><highlight class="comment"><sp/>*<sp/>(1)<sp/>in<sp/>realloc</highlight></codeline>
<codeline lineno="33"><highlight class="comment"><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal"></highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdio.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdlib.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdint.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="39"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stddef.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;sys/mman.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;string.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="42"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;unistd.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;stdbool.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;assert.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;pthread.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;errno.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="47"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;malloc.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="48"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="allocator_8h" kindref="compound">allocator.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="49"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;<ref refid="debug_8h" kindref="compound">debug.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="50"><highlight class="normal"></highlight></codeline>
<codeline lineno="51"><highlight class="normal"></highlight><highlight class="comment">//<sp/>TODO:<sp/>add<sp/>thread<sp/>safety</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal">pthread_mutex_t<sp/>thread_safety<sp/>=<sp/>PTHREAD_MUTEX_INITIALIZER;</highlight></codeline>
<codeline lineno="53"><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="allocator_8c_1a16e4f54f08fa2ef1574b413d64a94d44" kindref="member">print_memory</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">)</highlight></codeline>
<codeline lineno="62"><highlight class="normal">{</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(stdout,<sp/></highlight><highlight class="stringliteral">&quot;--<sp/>Current<sp/>Memory<sp/>State<sp/>--\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current_block<sp/>=<sp/>g_head;</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current_region<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(current_block<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(current_block-&gt;<ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>!=<sp/>current_region)<sp/>{</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_region<sp/>=<sp/>current_block-&gt;<ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref>;</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stdout,<sp/></highlight><highlight class="stringliteral">&quot;[REGION]<sp/>%p-%p<sp/>%zu\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_region,</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)<sp/>current_region<sp/>+<sp/>current_region-&gt;<ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>,</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_region-&gt;<ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>);</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(stdout,<sp/></highlight><highlight class="stringliteral">&quot;[BLOCK]<sp/><sp/>%p-%p<sp/>(%lu)<sp/>&apos;%s&apos;<sp/>%zu<sp/>%zu<sp/>%zu\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block,</highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)<sp/>current_block<sp/>+<sp/>current_block-&gt;<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,</highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1ad42de1b76cc0aa74440d25db29ac647d" kindref="member">alloc_id</ref>,</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>,</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>,</highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>==<sp/>0</highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>?<sp/>0<sp/>:<sp/>current_block-&gt;<ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>-<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>));</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block<sp/>=<sp/>current_block-&gt;<ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="85"><highlight class="normal">}</highlight></codeline>
<codeline lineno="86"><highlight class="normal"></highlight></codeline>
<codeline lineno="94"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="allocator_8c_1a22a50f56d0ca25cf15ae958e096a9776" kindref="member">write_memory</ref>(FILE<sp/>*<sp/>fp)</highlight></codeline>
<codeline lineno="95"><highlight class="normal">{</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/>fprintf(fp,<sp/></highlight><highlight class="stringliteral">&quot;--<sp/>Current<sp/>Memory<sp/>State<sp/>--\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current_block<sp/>=<sp/>g_head;</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current_region<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(current_block<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(current_block-&gt;<ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>!=<sp/>current_region)<sp/>{</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_region<sp/>=<sp/>current_block-&gt;<ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref>;</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(fp,<sp/></highlight><highlight class="stringliteral">&quot;[REGION]<sp/>%p-%p<sp/>%zu\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_region,</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)<sp/>current_region<sp/>+<sp/>current_region-&gt;<ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>,</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_region-&gt;<ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>);</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fprintf(fp,<sp/></highlight><highlight class="stringliteral">&quot;[BLOCK]<sp/><sp/>%p-%p<sp/>(%lu)<sp/>&apos;%s&apos;<sp/>%zu<sp/>%zu<sp/>%zu\n&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block,</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)<sp/>current_block<sp/>+<sp/>current_block-&gt;<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1ad42de1b76cc0aa74440d25db29ac647d" kindref="member">alloc_id</ref>,</highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>,</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,</highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>,</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block-&gt;<ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>==<sp/>0</highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>?<sp/>0<sp/>:<sp/>current_block-&gt;<ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>-<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>));</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_block<sp/>=<sp/>current_block-&gt;<ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="118"><highlight class="normal">}</highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight></codeline>
<codeline lineno="128"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<ref refid="allocator_8c_1a512132f6d325316860cc6ac6bf0a366c" kindref="member">reuse</ref>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>)</highlight></codeline>
<codeline lineno="129"><highlight class="normal">{</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(g_head<sp/>==<sp/>NULL)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="131"><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>using<sp/>free<sp/>space<sp/>management<sp/>algorithms,<sp/>find<sp/>a<sp/>block<sp/>of<sp/>memory<sp/>that</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>can<sp/>reuse.<sp/>Return<sp/>NULL<sp/>if<sp/>no<sp/>suitable<sp/>block<sp/>is<sp/>found.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>use<sp/>first_fit<sp/>by<sp/>default<sp/>if<sp/>there<sp/>is<sp/>no<sp/>algorithm<sp/>given</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>algo<sp/>=<sp/>getenv(</highlight><highlight class="stringliteral">&quot;ALLOCATOR_ALGORITHM&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(algo<sp/>==<sp/>NULL)<sp/></highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>algo<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;first_fit&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strcmp(algo,<sp/></highlight><highlight class="stringliteral">&quot;first_fit&quot;</highlight><highlight class="normal">)<sp/>==<sp/>0)<sp/></highlight></codeline>
<codeline lineno="143"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="144"><highlight class="normal"></highlight></codeline>
<codeline lineno="145"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>first<sp/>fit<sp/>block<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current<sp/>=<sp/>g_head;</highlight></codeline>
<codeline lineno="147"><highlight class="normal"></highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(current<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="150"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//find<sp/>the<sp/>first<sp/>actual<sp/>free<sp/>available<sp/>amount<sp/>of<sp/>memory<sp/>within<sp/>a<sp/>given<sp/>region</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>free_space<sp/>=<sp/>(current<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>)<sp/>-<sp/>(current<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>);</highlight></codeline>
<codeline lineno="152"><highlight class="normal"></highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//aligning<sp/>the<sp/>memory<sp/>allocation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>requested<sp/>=<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref>);</highlight></codeline>
<codeline lineno="155"><highlight class="normal"></highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(free_space<sp/>&gt;=<sp/>requested)<sp/></highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;reuse<sp/>-&gt;<sp/>first_fit:<sp/>returning<sp/>start<sp/>to<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>current);</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>current;</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="161"><highlight class="normal"></highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current<sp/>=<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="164"><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//memory<sp/>region<sp/>with<sp/>enough<sp/>space<sp/>in<sp/>it<sp/>was<sp/>not<sp/>found</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="168"><highlight class="normal"></highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strcmp(algo,<sp/></highlight><highlight class="stringliteral">&quot;best_fit&quot;</highlight><highlight class="normal">)<sp/>==<sp/>0)<sp/></highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>best<sp/>fit<sp/>block<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>block<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current<sp/>=<sp/>g_head;</highlight></codeline>
<codeline lineno="174"><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(current<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>free<sp/>space<sp/>of<sp/>the<sp/>current<sp/>block<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>free_space<sp/>=<sp/>(current<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>)<sp/>-<sp/>(current<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>);</highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>user<sp/>size<sp/>to<sp/>malloc<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>requested<sp/>=<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref>);</highlight></codeline>
<codeline lineno="182"><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(free_space<sp/>&gt;=<sp/>requested<sp/>&amp;&amp;<sp/>block<sp/>==<sp/>NULL)<sp/></highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>current;</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(free_space<sp/>&gt;=<sp/>requested<sp/>&amp;&amp;<sp/>block<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>previously_found_block_free_space<sp/>=<sp/>block<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>-<sp/>block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>;</highlight></codeline>
<codeline lineno="190"><highlight class="normal"></highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(free_space<sp/>&lt;<sp/>previously_found_block_free_space)</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>current;</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="196"><highlight class="normal"></highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current<sp/>=<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>block;</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="201"><highlight class="normal"></highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strcmp(algo,<sp/></highlight><highlight class="stringliteral">&quot;worst_fit&quot;</highlight><highlight class="normal">)<sp/>==<sp/>0)<sp/></highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>worst<sp/>fit<sp/>block<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>block<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current<sp/>=<sp/>g_head;</highlight></codeline>
<codeline lineno="208"><highlight class="normal"></highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(current<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>free<sp/>space<sp/>of<sp/>the<sp/>current<sp/>block<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>free_space<sp/>=<sp/>(current<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>)<sp/>-<sp/>(current<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>);</highlight></codeline>
<codeline lineno="213"><highlight class="normal"></highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>user<sp/>size<sp/>to<sp/>malloc<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>requested<sp/>=<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref>);</highlight></codeline>
<codeline lineno="216"><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(free_space<sp/>&gt;=<sp/>requested<sp/>&amp;&amp;<sp/>block<sp/>==<sp/>NULL)<sp/></highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>current;</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(free_space<sp/>&gt;=<sp/>requested<sp/>&amp;&amp;<sp/>block<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>previously_found_block_free_space<sp/>=<sp/>block<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>-<sp/>block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>;</highlight></codeline>
<codeline lineno="224"><highlight class="normal"></highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(free_space<sp/>&gt;<sp/>previously_found_block_free_space)<sp/></highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>=<sp/>current;</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="230"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current<sp/>=<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="231"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="232"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>block;</highlight></codeline>
<codeline lineno="233"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="234"><highlight class="normal"></highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//returns<sp/>null<sp/>here<sp/>for<sp/>syntactical<sp/>reasons<sp/>and<sp/>if<sp/>the<sp/>algo<sp/>isn&apos;t<sp/>correctly<sp/>formatted<sp/>for<sp/>whatever<sp/>reason</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="237"><highlight class="normal">}</highlight></codeline>
<codeline lineno="238"><highlight class="normal"></highlight></codeline>
<codeline lineno="246"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<ref refid="allocator_8c_1a7ac38fce3243a7dcf448301ee9ffd392" kindref="member">malloc</ref>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>)</highlight></codeline>
<codeline lineno="247"><highlight class="normal">{</highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;Using<sp/>my<sp/>custom<sp/>allocator<sp/>instead<sp/>of<sp/>the<sp/>system<sp/>call\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>nm<sp/>=<sp/></highlight><highlight class="stringliteral">&quot;mem_block&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;entering<sp/>custom<sp/>malloc\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<sp/>space<sp/>=<sp/><ref refid="allocator_8c_1aec0d19cf0c75e35fef6e0c1248dc781e" kindref="member">malloc_name</ref>(<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,<sp/>nm);</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;malloc<sp/>name<sp/>returned<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>space);</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>space;</highlight></codeline>
<codeline lineno="254"><highlight class="normal">}</highlight></codeline>
<codeline lineno="255"><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<ref refid="allocator_8c_1aec0d19cf0c75e35fef6e0c1248dc781e" kindref="member">malloc_name</ref>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,<sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/><ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>)</highlight></codeline>
<codeline lineno="265"><highlight class="normal">{</highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/>pthread_mutex_lock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;Allocation<sp/>request<sp/>with<sp/>size<sp/>=<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>);</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>allocate<sp/>memory.<sp/>You&apos;ll<sp/>first<sp/>check<sp/>if<sp/>you<sp/>can<sp/>reuse<sp/>an<sp/>existing</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>block.<sp/>If<sp/>not,<sp/>map<sp/>a<sp/>new<sp/>memory<sp/>region.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>malloc<sp/>returns<sp/>null<sp/>when<sp/>the<sp/>size<sp/>is<sp/>zero<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;size<sp/>was<sp/>0\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="277"><highlight class="normal"></highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>%<sp/>8<sp/>!=<sp/>0)<sp/></highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+=<sp/>8<sp/>-<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>%<sp/>8;</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="282"><highlight class="normal"></highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;Adjusted<sp/>size<sp/>is<sp/>%zu<sp/>(if<sp/>it<sp/>was<sp/>needed)\n&quot;</highlight><highlight class="normal">,<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>);</highlight></codeline>
<codeline lineno="284"><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>)<sp/>&gt;<sp/>M_MMAP_THRESHOLD)<sp/></highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;what<sp/>is<sp/>size<sp/>max<sp/>%d\n&quot;</highlight><highlight class="normal">,<sp/>M_MMAP_THRESHOLD);</highlight></codeline>
<codeline lineno="291"><highlight class="normal"></highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/>ask<sp/>about<sp/>here:<sp/>casting<sp/>to<sp/>mem<sp/>block<sp/>from<sp/>reuse</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>unused_memory;</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<sp/>(unused_memory<sp/>=<sp/><ref refid="allocator_8c_1a512132f6d325316860cc6ac6bf0a366c" kindref="member">reuse</ref>(<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>))<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>=<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref>);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1ad42de1b76cc0aa74440d25db29ac647d" kindref="member">alloc_id</ref><sp/>=<sp/>g_allocations++;</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>,<sp/><ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>);</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>unused_memory<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="304"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;There<sp/>is<sp/>unused<sp/>memory<sp/>and<sp/>the<sp/>process<sp/>has<sp/>been<sp/>locked\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="305"><highlight class="normal"></highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>finish<sp/>the<sp/>resize<sp/>code<sp/>without<sp/>the<sp/>free<sp/>block<sp/>and<sp/>see<sp/>how<sp/>that<sp/>code<sp/>goes</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="307"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>org_size<sp/>=<sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>;</highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;size<sp/>of<sp/>unused<sp/>memory<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/>org_size);</highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>org_usage<sp/>=<sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>;</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>next_block<sp/>=<sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>needed_space<sp/>=<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref>);</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/></highlight></codeline>
<codeline lineno="313"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>This<sp/>line<sp/>is<sp/>for<sp/>adding<sp/>a<sp/>free<sp/>block<sp/>after;<sp/>however,<sp/>because<sp/>that<sp/>can<sp/>get</highlight></codeline>
<codeline lineno="314"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>difficult<sp/>when<sp/>it<sp/>comes<sp/>to<sp/>logic<sp/>and<sp/>checking,<sp/>it<sp/>may<sp/>be<sp/>better<sp/>to<sp/>just</highlight></codeline>
<codeline lineno="315"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>keep<sp/>things<sp/>simple<sp/>and<sp/>just<sp/>have<sp/>the<sp/>initial<sp/>space<sp/>and<sp/>the<sp/>new<sp/>block</highlight></codeline>
<codeline lineno="316"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>without<sp/>creating<sp/>a<sp/>free_block</highlight></codeline>
<codeline lineno="317"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;malloc<sp/>-&gt;<sp/>reuse:unused_memory<sp/>start<sp/>%p<sp/>to<sp/>%p<sp/>and<sp/>usage<sp/>is<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/>unused_memory,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)unused_memory<sp/>+<sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,<sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>);</highlight></codeline>
<codeline lineno="319"><highlight class="normal"></highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>code<sp/>for<sp/>splitting<sp/>the<sp/>memory<sp/>up<sp/>that<sp/>needs<sp/>to<sp/>be<sp/>freed<sp/>that<sp/>is<sp/>extra<sp/>should<sp/>go<sp/>here<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>new_block<sp/>=<sp/>(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*)<sp/>((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)unused_memory<sp/>+<sp/>org_usage);</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>=<sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref>;</highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>=<sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>-<sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>;</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;free_space<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>);</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>=<sp/>needed_space;</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1ad42de1b76cc0aa74440d25db29ac647d" kindref="member">alloc_id</ref><sp/>=<sp/>g_allocations++;</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>next_block;</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>strcpy(new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>,<sp/><ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>);</highlight></codeline>
<codeline lineno="329"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;malloc<sp/>-&gt;<sp/>reuse<sp/>new_block:<sp/>%p-%p<sp/>(%lu)<sp/>&apos;%s&apos;<sp/>%zu<sp/>%zu<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/>new_block,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)new_block<sp/>+<sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,<sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1ad42de1b76cc0aa74440d25db29ac647d" kindref="member">alloc_id</ref>,<sp/></highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>,<sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,<sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>,<sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>-<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>));</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>region_size<sp/>of<sp/>the<sp/>new_block<sp/>is<sp/>undefined<sp/>because<sp/>it<sp/>is<sp/>a<sp/>split<sp/>block<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="332"><highlight class="normal"></highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/></highlight></codeline>
<codeline lineno="334"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>updating<sp/>the<sp/>original<sp/>block<sp/>space<sp/>so<sp/>that<sp/>it<sp/></highlight></codeline>
<codeline lineno="335"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>reflects<sp/>the<sp/>changes<sp/>of<sp/>having<sp/>been<sp/>split</highlight></codeline>
<codeline lineno="336"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>=<sp/>org_usage;</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>unused_memory<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>new_block;</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;malloc<sp/>-&gt;<sp/>reuse<sp/>new_block:<sp/>data<sp/>end<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)new_block<sp/>+<sp/>new_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>);</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>new_block<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="343"><highlight class="normal"></highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>seting<sp/>up<sp/>the<sp/>page<sp/>size,<sp/>the<sp/>actual<sp/>size<sp/>of<sp/>the<sp/>memory,<sp/>and<sp/>the<sp/>number<sp/>of<sp/>pages<sp/>the<sp/>memory<sp/>region<sp/>should<sp/>have<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>page_size<sp/>=<sp/>getpagesize();</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>actual_size<sp/>=<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref>);</highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>number_of_pages<sp/>=<sp/>actual_size<sp/>/<sp/>page_size;</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;page<sp/>size<sp/>%d<sp/>actual<sp/>size<sp/>%zu<sp/>number<sp/>of<sp/>pages<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/>page_size,<sp/>actual_size,<sp/>number_of_pages);</highlight></codeline>
<codeline lineno="349"><highlight class="normal"></highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>always<sp/>allocating<sp/>at<sp/>least<sp/>a<sp/>page<sp/>of<sp/>memory<sp/>no<sp/>matter<sp/>what<sp/>...<sp/>ask<sp/>about<sp/>here<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(actual_size<sp/>%<sp/>page_size<sp/>!=<sp/>0)</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>number_of_pages++;</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="355"><highlight class="normal"></highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;number<sp/>of<sp/>pages<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/>number_of_pages);</highlight></codeline>
<codeline lineno="357"><highlight class="normal"></highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref><sp/>=<sp/>number_of_pages<sp/>*<sp/>page_size;</highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;region<sp/>size<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>);</highlight></codeline>
<codeline lineno="360"><highlight class="normal"></highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="362"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Create<sp/>the<sp/>memory<sp/>block</highlight></codeline>
<codeline lineno="363"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>MMAP_THRESHOLD<sp/>When<sp/>allocating<sp/>blocks<sp/>of<sp/>memory<sp/>larger<sp/>than<sp/>MMAP_THRESHOLD<sp/>bytes,<sp/>the<sp/>glibc<sp/>malloc()</highlight></codeline>
<codeline lineno="364"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>implementation<sp/>allocates<sp/>the<sp/>memory<sp/>as<sp/>a<sp/>private<sp/>anonymous<sp/>mapping<sp/>using<sp/>mmap(2).<sp/>Hence,<sp/>the<sp/>need</highlight></codeline>
<codeline lineno="365"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>for<sp/>using<sp/>MAP_ANONYMOUS<sp/>when<sp/>calling<sp/>mmap</highlight></codeline>
<codeline lineno="366"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>region<sp/>=<sp/>mmap(NULL,<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>,<sp/>PROT_READ<sp/>|<sp/>PROT_WRITE,<sp/>MAP_PRIVATE<sp/>|<sp/>MAP_ANONYMOUS,<sp/>-1,<sp/>0);</highlight></codeline>
<codeline lineno="368"><highlight class="normal"></highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>checking<sp/>to<sp/>see<sp/>if<sp/>mapping<sp/>the<sp/>address<sp/>of<sp/>memory<sp/>had<sp/>failed<sp/>for<sp/>some<sp/>reason<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="370"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(region<sp/>==<sp/>MAP_FAILED)</highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;error<sp/>mapping<sp/>memory\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;mmap&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="374"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;mapped<sp/>memory\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="378"><highlight class="normal"></highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">char</highlight><highlight class="normal"><sp/>*<sp/>scribble<sp/>=<sp/>getenv(</highlight><highlight class="stringliteral">&quot;ALLOCATOR_SCRIBBLE&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="380"><highlight class="normal"></highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;got<sp/>%s<sp/>for<sp/>scribble\n&quot;</highlight><highlight class="normal">,<sp/>scribble);</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>scribble<sp/>with<sp/>junk<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(scribble<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(strcmp(scribble,<sp/></highlight><highlight class="stringliteral">&quot;1&quot;</highlight><highlight class="normal">)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{<sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;memset<sp/>fail?\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)region<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>),<sp/>0xAA,<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref><sp/>-<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>));</highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>memset((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)region<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>),<sp/>0xAA,<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref><sp/>-<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>));</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>clear<sp/>instead;<sp/>no<sp/>need<sp/>to<sp/>scribble<sp/>with<sp/>0xAA<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;memset<sp/>fail?\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>memset((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)region<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>),<sp/>0xAA,<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref><sp/>-<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>));</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="398"><highlight class="normal"></highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;memset<sp/>worked\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="400"><highlight class="normal"></highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>setting<sp/>up<sp/>the<sp/>region<sp/>mem_block<sp/>structure<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/>strcpy(region<sp/>-&gt;<sp/><ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>,<sp/><ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>);</highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1ad42de1b76cc0aa74440d25db29ac647d" kindref="member">alloc_id</ref><sp/>=<sp/>g_allocations++;</highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>=<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>;</highlight></codeline>
<codeline lineno="405"><highlight class="normal"><sp/><sp/><sp/><sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>=<sp/>actual_size;</highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>=<sp/>region;</highlight></codeline>
<codeline lineno="407"><highlight class="normal"><sp/><sp/><sp/><sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref><sp/>=<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>;</highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;malloc<sp/>-&gt;<sp/>region:<sp/>%p-%p<sp/>(%lu)<sp/>&apos;%s&apos;<sp/>%zu<sp/>%zu<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/>region,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)region<sp/>+<sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,<sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1ad42de1b76cc0aa74440d25db29ac647d" kindref="member">alloc_id</ref>,<sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a4b0bf81628ebd136cc6d4a33c2dc1fcf" kindref="member">name</ref>,<sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>,</highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>,<sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>-<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>));</highlight></codeline>
<codeline lineno="411"><highlight class="normal"></highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>adding<sp/>the<sp/>memory<sp/>allocation<sp/>to<sp/>the<sp/>linked<sp/>list<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(g_head<sp/>==<sp/>NULL)</highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//set<sp/>the<sp/>head<sp/>of<sp/>the<sp/>linked<sp/>list</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g_head<sp/>=<sp/>region;</highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="420"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//find<sp/>the<sp/>last<sp/>region<sp/>of<sp/>memory<sp/>and<sp/>then</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="421"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current<sp/>=<sp/>g_head;</highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>!=<sp/>NULL)<sp/>current<sp/>=<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>region;</highlight></codeline>
<codeline lineno="424"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;current<sp/>%p<sp/>and<sp/>the<sp/>next<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>current,<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>);</highlight></codeline>
<codeline lineno="425"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="426"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>returning<sp/>where<sp/>the<sp/>memory<sp/>after<sp/>the<sp/>region<sp/>struct<sp/>starts<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="427"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;Data<sp/>end<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*)region<sp/>+<sp/>region<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>);</highlight></codeline>
<codeline lineno="428"><highlight class="normal"><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="429"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>region<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="430"><highlight class="normal">}</highlight></codeline>
<codeline lineno="431"><highlight class="normal"></highlight></codeline>
<codeline lineno="439"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="allocator_8c_1afbedc913aa4651b3c3b4b3aecd9b4711" kindref="member">free</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*ptr)</highlight></codeline>
<codeline lineno="440"><highlight class="normal">{</highlight></codeline>
<codeline lineno="441"><highlight class="normal"><sp/><sp/><sp/><sp/>pthread_mutex_lock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ptr<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Freeing<sp/>a<sp/>NULL<sp/>pointer<sp/>does<sp/>nothing<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="447"><highlight class="normal"></highlight></codeline>
<codeline lineno="448"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>free<sp/>the<sp/>block<sp/>from<sp/>the<sp/>start<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>freed_block<sp/>=<sp/>(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*)<sp/>ptr<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/>freed_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;freed<sp/>block<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>freed_block);</highlight></codeline>
<codeline lineno="452"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(ptr,<sp/>0xAA,<sp/>freed_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>-<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct</highlight><highlight class="normal"><sp/><ref refid="structmem__block" kindref="compound">mem_block</ref>));</highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//blocks</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="454"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current<sp/>=<sp/>g_head;</highlight></codeline>
<codeline lineno="455"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>last<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="457"><highlight class="normal"></highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//region<sp/>beginnings<sp/>and<sp/>endings</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>current_first<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="460"><highlight class="normal"></highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(freed_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>==<sp/>g_head)</highlight></codeline>
<codeline lineno="462"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(current<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(current<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>!=<sp/>0)<sp/></highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;%p<sp/>has<sp/>a<sp/>non<sp/>zero<sp/>usage\n&quot;</highlight><highlight class="normal">,<sp/>current);</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="471"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>==<sp/>NULL</highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>!=<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref>)</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last<sp/>=<sp/>current;</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;looping<sp/>is<sp/>finished\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="477"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="479"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current<sp/>=<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="480"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="481"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>g_head<sp/>=<sp/>(last<sp/>==<sp/>NULL)?<sp/>NULL<sp/>:<sp/>last<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="482"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="483"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current_first<sp/>=<sp/>freed_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref>;</highlight></codeline>
<codeline lineno="484"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>value<sp/>=<sp/>munmap(current_first,<sp/>current_first<sp/>-&gt;<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>);</highlight></codeline>
<codeline lineno="485"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(value<sp/>==<sp/>-1)<sp/></highlight></codeline>
<codeline lineno="486"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="487"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;munmapped<sp/>has<sp/>failed<sp/>T~T\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="488"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;munmap&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="489"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="490"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;unmapped<sp/>memory<sp/>correctly<sp/>^o^\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="494"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="495"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//blocks:<sp/>also<sp/>setting<sp/>the<sp/>blocks<sp/>to<sp/>initial<sp/>postitions<sp/>just<sp/>in<sp/>case<sp/>there<sp/>are<sp/>any<sp/>edge<sp/>cases<sp/>I<sp/>may<sp/>be<sp/>forgetting<sp/>somehow</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="496"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>previous<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="497"><highlight class="normal"><sp/><sp/><sp/><sp/>current<sp/>=<sp/>g_head;</highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/>last<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;region<sp/>to<sp/>free<sp/>is<sp/>not<sp/>be<sp/>g_head\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="501"><highlight class="normal"></highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//region<sp/>beginnings<sp/>and<sp/>endings:<sp/>also<sp/>setting<sp/>the<sp/>regionss<sp/>to<sp/>initial<sp/>postitions<sp/>just<sp/>in<sp/>case<sp/>there<sp/>are<sp/>any<sp/>edge<sp/>cases<sp/>I<sp/>may<sp/>be<sp/>forgetting<sp/>somehow</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>previous_last<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/>current_first<sp/>=<sp/>freed_block<sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref>;</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>next_first<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="506"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(current<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//look<sp/>for<sp/>previous<sp/>block</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="510"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>!=<sp/>current_first<sp/>&amp;&amp;<sp/>previous_last<sp/>==<sp/>NULL)</highlight></codeline>
<codeline lineno="511"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="512"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>previous<sp/>=<sp/>current;</highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current<sp/>=<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="514"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;previous<sp/>%p<sp/>and<sp/>current<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>previous,<sp/>current);</highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="517"><highlight class="normal"></highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//set<sp/>previous<sp/>block<sp/>once</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>==<sp/>current_first<sp/>&amp;&amp;<sp/>previous_last<sp/>==<sp/>NULL)</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="521"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>previous_last<sp/>=<sp/>current;</highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current<sp/>=<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;previous_last<sp/>is<sp/>set<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>previous_last);</highlight></codeline>
<codeline lineno="524"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;next<sp/>is<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>);</highlight></codeline>
<codeline lineno="526"><highlight class="normal"></highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//find<sp/>the<sp/>last<sp/>block<sp/>in<sp/>current<sp/>region</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="528"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">((current<sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>==<sp/>current_first<sp/>&amp;&amp;<sp/>previous_last<sp/>!=<sp/>NULL)<sp/>||<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref><sp/>==<sp/>current_first<sp/>-&gt;<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>)</highlight></codeline>
<codeline lineno="529"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(current<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>!=<sp/>0)<sp/></highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;%p<sp/>has<sp/>a<sp/>non<sp/>zero<sp/>usage\n&quot;</highlight><highlight class="normal">,<sp/>current);</highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="537"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>==<sp/>NULL</highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>||<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref><sp/>!=<sp/>current<sp/>-&gt;<sp/><ref refid="structmem__block_1a13488653e52b16c20a2236a540e2f0cc" kindref="member">region_start</ref>)</highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>last<sp/>=<sp/>current;</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;looping<sp/>is<sp/>finished\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>current<sp/>=<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">continue</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="547"><highlight class="normal"></highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="549"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;time<sp/>to<sp/>free<sp/>a<sp/>region\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/>next_first<sp/>=<sp/>(last<sp/><sp/>==<sp/>NULL)?<sp/>NULL<sp/>:<sp/>last<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref>;</highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/>previous_last<sp/>-&gt;<sp/><ref refid="structmem__block_1a6bc667eb00ed1bb2d18b4074a69d7cf4" kindref="member">next</ref><sp/>=<sp/>next_first;</highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;previous<sp/>region<sp/>last<sp/>block<sp/>%p<sp/>and<sp/>next<sp/>region<sp/>first<sp/>block<sp/>%p\n&quot;</highlight><highlight class="normal">,<sp/>previous_last,<sp/>next_first);</highlight></codeline>
<codeline lineno="554"><highlight class="normal"></highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>value<sp/>=<sp/>munmap(current_first,<sp/>current_first<sp/>-&gt;<sp/><ref refid="structmem__block_1a9363cab5adbbfa3e4655a226262be3f9" kindref="member">region_size</ref>);</highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(value<sp/>==<sp/>-1)</highlight></codeline>
<codeline lineno="557"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;munmapped<sp/>has<sp/>failed<sp/>T~T\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perror(</highlight><highlight class="stringliteral">&quot;munmap&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="560"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="561"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;unmapped<sp/>memory<sp/>correctly<sp/>^o^\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="563"><highlight class="normal"><sp/><sp/><sp/><sp/>pthread_mutex_unlock(&amp;thread_safety);</highlight></codeline>
<codeline lineno="564"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="565"><highlight class="normal"></highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*</highlight></codeline>
<codeline lineno="567"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>TODO:<sp/>finish<sp/>code<sp/>for<sp/>a<sp/>previous_region,<sp/>current_region,<sp/>and<sp/>next_region<sp/>when<sp/>going<sp/>through<sp/>a<sp/>region</highlight></codeline>
<codeline lineno="568"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>check<sp/>to<sp/>see<sp/>if<sp/>we<sp/>need<sp/>to<sp/>free<sp/>regions<sp/>and<sp/>fix<sp/>the<sp/>linked<sp/>list</highlight></codeline>
<codeline lineno="569"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/></highlight></codeline>
<codeline lineno="570"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>TODO:<sp/>FINDING<sp/>REGION<sp/>TO<sp/>UNMAP<sp/>IF<sp/>NEEDED</highlight></codeline>
<codeline lineno="571"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>Always<sp/>unmapping<sp/>the<sp/>current_region(∆)<sp/>if<sp/>it<sp/>is<sp/>needed</highlight></codeline>
<codeline lineno="572"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>previous_region<sp/>|<sp/>current_region<sp/>|<sp/>next_region</highlight></codeline>
<codeline lineno="573"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>p<sp/>c<sp/>n</highlight></codeline>
<codeline lineno="574"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>-<sp/>-<sp/>-<sp/>–&gt;<sp/>fixing<sp/>linked<sp/>list</highlight></codeline>
<codeline lineno="575"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>n<sp/>∆<sp/>n<sp/>–&gt;<sp/>g_head<sp/>=<sp/>NULL<sp/>||<sp/>next_region;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>either<sp/>of<sp/>can<sp/>be<sp/>used<sp/>because<sp/>next_region<sp/>will<sp/>be<sp/>NULL</highlight></codeline>
<codeline lineno="576"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>n<sp/>∆<sp/>•<sp/>–&gt;<sp/>g_head<sp/>=<sp/>next_region;</highlight></codeline>
<codeline lineno="577"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>•<sp/>∆<sp/>n<sp/>–&gt;<sp/>previous_region<sp/>-&gt;<sp/>next<sp/>=<sp/>NULL<sp/>||<sp/>next_region;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>either<sp/>of<sp/>can<sp/>be<sp/>used<sp/>because<sp/>next_region<sp/>will<sp/>be<sp/>NULL</highlight></codeline>
<codeline lineno="578"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>•<sp/>∆<sp/>•<sp/>–&gt;<sp/>previous_region<sp/>-&gt;<sp/>next<sp/>=<sp/>next_region;</highlight></codeline>
<codeline lineno="579"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/></highlight></codeline>
<codeline lineno="580"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/></highlight></codeline>
<codeline lineno="581"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/></highlight></codeline>
<codeline lineno="582"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/></highlight></codeline>
<codeline lineno="583"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="584"><highlight class="normal">}</highlight></codeline>
<codeline lineno="585"><highlight class="normal"></highlight></codeline>
<codeline lineno="593"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<ref refid="allocator_8c_1a62b7798461bd461da64c5f9d35feddf7" kindref="member">calloc</ref>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>nmemb,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>)</highlight></codeline>
<codeline lineno="594"><highlight class="normal">{</highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(nmemb<sp/>==<sp/>0<sp/>||<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>==<sp/>0)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="596"><highlight class="normal"></highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>requested<sp/>size<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>max<sp/>=<sp/>nmemb<sp/>*<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>;</highlight></codeline>
<codeline lineno="599"><highlight class="normal"></highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>adjusted<sp/>data<sp/>size<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="601"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(max<sp/>%<sp/>8<sp/>!=<sp/>0)<sp/>max<sp/>+=<sp/>8<sp/>-<sp/>max<sp/>%<sp/>8;</highlight></codeline>
<codeline lineno="602"><highlight class="normal"></highlight></codeline>
<codeline lineno="603"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>header<sp/>and<sp/>the<sp/>data<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="604"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>adjusted_max<sp/>=<sp/>max<sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref>);</highlight></codeline>
<codeline lineno="605"><highlight class="normal"></highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>if<sp/>there<sp/>won&apos;t<sp/>be<sp/>enough<sp/>for<sp/>the<sp/>full<sp/>space<sp/>due<sp/>to<sp/>overflow<sp/>...ask<sp/>about<sp/>here<sp/>for<sp/>overflow*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(adjusted_max<sp/>&gt;<sp/>SIZE_MAX)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="608"><highlight class="normal"></highlight></codeline>
<codeline lineno="609"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>question<sp/>about<sp/>the<sp/>where<sp/>overflow<sp/>is<sp/>needed;<sp/>it<sp/>should<sp/>only<sp/>be<sp/>here?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="610"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>I<sp/>may<sp/>not<sp/>need<sp/>to<sp/>do<sp/>the<sp/>three<sp/>previous</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="611"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>lines<sp/>of<sp/>code<sp/>but<sp/>doing<sp/>so<sp/>may<sp/>make<sp/>sure<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="612"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>amount<sp/>of<sp/>memory<sp/>aligned<sp/>and<sp/>adjusted<sp/>with</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="613"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>struct<sp/>won&apos;t<sp/>cause<sp/>an<sp/>overflow<sp/>issue</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Answer:<sp/>in<sp/>terms<sp/>of<sp/>known<sp/>implementation,<sp/>overflow<sp/>happens<sp/>here<sp/>where<sp/>as</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="615"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>in<sp/>malloc<sp/>it<sp/>an<sp/>integer<sp/>overflow<sp/>would<sp/>not<sp/>be<sp/>detected</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="616"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>hmm,<sp/>what<sp/>does<sp/>calloc<sp/>do?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="617"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<sp/>pointer<sp/>=<sp/><ref refid="allocator_8c_1a7ac38fce3243a7dcf448301ee9ffd392" kindref="member">malloc</ref>(max);</highlight></codeline>
<codeline lineno="618"><highlight class="normal"></highlight></codeline>
<codeline lineno="619"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(!pointer)</highlight></codeline>
<codeline lineno="620"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="621"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>errno<sp/>=<sp/>ENOMEM;</highlight></codeline>
<codeline lineno="622"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="623"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="624"><highlight class="normal"></highlight></codeline>
<codeline lineno="625"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(pointer,<sp/>0,<sp/>max);</highlight></codeline>
<codeline lineno="626"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//cleared<sp/>data<sp/>yaaaaay!</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="627"><highlight class="normal"></highlight></codeline>
<codeline lineno="628"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pointer;</highlight></codeline>
<codeline lineno="629"><highlight class="normal">}</highlight></codeline>
<codeline lineno="630"><highlight class="normal"></highlight></codeline>
<codeline lineno="640"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<ref refid="allocator_8c_1a1a6b5e8d2f1c37e5b43e4345586075be" kindref="member">realloc</ref>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*ptr,<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>)</highlight></codeline>
<codeline lineno="641"><highlight class="normal">{</highlight></codeline>
<codeline lineno="642"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ptr<sp/>==<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>If<sp/>the<sp/>pointer<sp/>is<sp/>NULL,<sp/>then<sp/>we<sp/>simply<sp/>malloc<sp/>a<sp/>new<sp/>block<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="644"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="allocator_8c_1a7ac38fce3243a7dcf448301ee9ffd392" kindref="member">malloc</ref>(<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>);</highlight></codeline>
<codeline lineno="645"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="646"><highlight class="normal"></highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>==<sp/>0)<sp/>{</highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Realloc<sp/>to<sp/>0<sp/>is<sp/>often<sp/>the<sp/>same<sp/>as<sp/>freeing<sp/>the<sp/>memory<sp/>block...<sp/>But<sp/>the</highlight></codeline>
<codeline lineno="649"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>C<sp/>standard<sp/>doesn&apos;t<sp/>require<sp/>this.<sp/>We<sp/>will<sp/>free<sp/>the<sp/>block<sp/>and<sp/>return</highlight></codeline>
<codeline lineno="650"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*<sp/>NULL<sp/>here.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="651"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="allocator_8c_1afbedc913aa4651b3c3b4b3aecd9b4711" kindref="member">free</ref>(ptr);</highlight></codeline>
<codeline lineno="652"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="653"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="654"><highlight class="normal"></highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>%<sp/>8<sp/>!=<sp/>0)<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+=<sp/>8<sp/>-<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>%<sp/>8;</highlight></codeline>
<codeline lineno="656"><highlight class="normal"></highlight></codeline>
<codeline lineno="657"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>reallocation<sp/>logic</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*<sp/>block<sp/>=<sp/>(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref><sp/>*)<sp/>ptr<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="659"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>original_requested_space<sp/>=<sp/>(block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>);</highlight></codeline>
<codeline lineno="660"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>original_size<sp/>=<sp/>(block<sp/>-&gt;<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>);</highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>needed_allocation_space<sp/>=<sp/><ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref><sp/>+<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal"><ref refid="structmem__block" kindref="compound">mem_block</ref>);</highlight></codeline>
<codeline lineno="662"><highlight class="normal"></highlight></codeline>
<codeline lineno="663"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>TODO:<sp/>check<sp/>for<sp/>the<sp/>usage<sp/>if<sp/>it<sp/>can<sp/>be<sp/>resized<sp/>in<sp/>place<sp/>...<sp/>ask<sp/>about<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="664"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(original_requested_space<sp/>&lt;<sp/>original_size<sp/>&amp;&amp;<sp/>original_requested_space<sp/>&gt;=<sp/>needed_allocation_space)</highlight></codeline>
<codeline lineno="665"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="666"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref><sp/>=<sp/>needed_allocation_space;</highlight></codeline>
<codeline lineno="667"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="debug_8h_1a388edf12256bf73c3a8ee9734c3bd841" kindref="member">LOG</ref>(</highlight><highlight class="stringliteral">&quot;usage<sp/>of<sp/>realloc<sp/>block<sp/>%zu\n&quot;</highlight><highlight class="normal">,<sp/>block<sp/>-&gt;<sp/><ref refid="structmem__block_1a9584a3091a545d69554c90af09a537f9" kindref="member">usage</ref>);</highlight></codeline>
<codeline lineno="668"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>block<sp/>+<sp/>1;</highlight></codeline>
<codeline lineno="669"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="670"><highlight class="normal"></highlight></codeline>
<codeline lineno="671"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>if<sp/>there<sp/>isn&apos;t<sp/>enough<sp/>space<sp/>for<sp/>the<sp/>block<sp/>to<sp/>be<sp/>resized,<sp/>we<sp/>just<sp/>malloc<sp/>space;<sp/>malloc<sp/>also<sp/>handles<sp/>reusing<sp/>blocks<sp/>so<sp/>that<sp/>isn&apos;t<sp/>needed<sp/>to<sp/>be<sp/>done<sp/>here<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="672"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="debug_8h_1ac60a33fb6244dfed75a5aaab504b8968" kindref="member">LOGP</ref>(</highlight><highlight class="stringliteral">&quot;All<sp/>memory<sp/>is<sp/>used<sp/>in<sp/>linked<sp/>list<sp/>so<sp/>new<sp/>space<sp/>will<sp/>be<sp/>allocated\n&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>*<sp/>new_ptr;</highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/>new_ptr<sp/>=<sp/><ref refid="allocator_8c_1a7ac38fce3243a7dcf448301ee9ffd392" kindref="member">malloc</ref>(<ref refid="structmem__block_1a5ff4ee5dcd970bbc4951eb108c5eec4b" kindref="member">size</ref>);</highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!new_ptr)<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>NULL;</highlight></codeline>
<codeline lineno="676"><highlight class="normal"></highlight></codeline>
<codeline lineno="677"><highlight class="normal"><sp/><sp/><sp/><sp/>memcpy(new_ptr,<sp/>ptr,<sp/>original_size);</highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="allocator_8c_1afbedc913aa4651b3c3b4b3aecd9b4711" kindref="member">free</ref>(ptr);</highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>new_ptr;</highlight></codeline>
<codeline lineno="680"><highlight class="normal"></highlight></codeline>
<codeline lineno="681"><highlight class="normal">}</highlight></codeline>
<codeline lineno="682"><highlight class="normal"></highlight><highlight class="comment">//End<sp/>of<sp/>file</highlight><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="allocator.c"/>
  </compounddef>
</doxygen>
